/* $Id$ */
/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * <bonelli@antifork.org> wrote this file. As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return. Nicola Bonelli
 * ----------------------------------------------------------------------------
 */

#ifndef _SNIPPET_HPP_
#define _SNIPPET_HPP_ 

#include <cxxabi.h>

#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cassert>
#include <cmath>
#include <cctype>
#include <cerrno>
#include <climits>
#include <ctime>
#include <cstdint>

#include <iostream>
#include <fstream>
#include <sstream>
#include <streambuf>
#include <iomanip>
#include <stdexcept>
#include <typeinfo>
#include <memory>
#include <limits>
#include <numeric>
#include <utility>
#include <string>

#include <algorithm>
#include <functional>
#include <iterator>

#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>

#include <chrono>
#include <ratio>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <forward_list>

#if __GNUC__ == 4 &&  __GNUC_MINOR__ == 4  
#include <cstdatomic>
#elif __GNUC__ == 4 &&  __GNUC_MINOR__ == 5
#include <atomic>
#endif

#include <complex>
#include <cfenv>
#include <array>
#include <tuple>
#include <type_traits>
#include <random>
#include <regex>

#include <unordered_set>
#include <unordered_map>

//////////////////////////////////////////////////////// additional type_traits...

namespace more 
{
    namespace traits {

    // For use in __is_convertible_simple.
    struct __sfinae_types
    {
      typedef char __one;
      typedef struct { char __arr[2]; } __two;
    };

    // has member type helper (using SFINAE... Vandevoorde/Josuttis)
    #define __has_member_type_helper(abc) \
    template <typename T>   \
    class __has_ ## abc ## _helper : public __sfinae_types   \
    {   \
        template <typename C> static __one test(typename std::remove_reference<typename C::abc>::type *);  \
        template <typename C> static __two test(...);   \
    \
    public: \
        enum { value = sizeof(test<T>(0)) == sizeof(__one) };   \
    }

    __has_member_type_helper(value_type);
    __has_member_type_helper(pointer);
    __has_member_type_helper(reference);
    __has_member_type_helper(const_reference);
    __has_member_type_helper(iterator);
    __has_member_type_helper(const_iterator);
    __has_member_type_helper(reverse_iterator);
    __has_member_type_helper(const_reverse_iterator);
    __has_member_type_helper(size_type);
    __has_member_type_helper(difference_type);

    template <typename T>
    struct has_value_type : public std::integral_constant<bool, __has_value_type_helper<T>::value>
    {};

    template <typename T>
    struct has_pointer : public std::integral_constant<bool, __has_pointer_helper<T>::value>
    {};

    template <typename T>
    struct has_reference : public std::integral_constant<bool, __has_reference_helper<T>::value>
    {};

    template <typename T>
    struct has_const_reference : public std::integral_constant<bool, __has_const_reference_helper<T>::value>
    {};

    template <typename T>
    struct has_iterator : public std::integral_constant<bool, __has_iterator_helper<T>::value>
    {};

    template <typename T>
    struct has_const_iterator : public std::integral_constant<bool, __has_const_iterator_helper<T>::value>
    {};

    template <typename T>
    struct has_reverse_iterator : public std::integral_constant<bool, __has_reverse_iterator_helper<T>::value>
    {};

    template <typename T>
    struct has_const_reverse_iterator : public std::integral_constant<bool, __has_const_reverse_iterator_helper<T>::value>
    {};
    
    template <typename T>
    struct has_size_type : public std::integral_constant<bool, __has_size_type_helper<T>::value>
    {};
    
    template <typename T>
    struct has_difference_type : public std::integral_constant<bool, __has_difference_type_helper<T>::value>
    {};
    
    template <typename T>
    struct is_container : public std::integral_constant<bool, __has_value_type_helper<T>::value && 
                                                              __has_reference_helper<T>::value &&  
                                                              __has_const_reference_helper<T>::value &&  
                                                              __has_iterator_helper<T>::value && 
                                                              __has_const_iterator_helper<T>::value && 
                                                              __has_pointer_helper<T>::value &&  
                                                              __has_size_type_helper<T>::value &&  
                                                              __has_difference_type_helper<T>::value 
                                                               >
    {};

    // is_tuple 
    //

    template <typename T>
    class __is_tuple_helper : public __sfinae_types
    {
        template <typename C> static __one test(typename std::tuple_element<std::tuple_size<C>::value-1, C>::type *);
        template <typename C> static __two test(...);

    public:
        enum { value = sizeof(test<T>(0)) == sizeof(__one) };
    };

    template <typename T>
    struct is_tuple : public std::integral_constant<bool, __is_tuple_helper<T>::value || std::is_same<T, std::tuple<>>::value >
    {};

    } // namespace traits

} // namespace more 

////////////////////////////////////////////////////////////// streamer

namespace more { namespace streamer {

    // construction-on-the-first idiom ensures index will be unique  
    //

    struct sep {

        sep(const char *s = NULL)
        : _M_value(s)
        {}

        static int index()
        {
            static int i = std::ios_base::xalloc();
            return i;
        }

        const char * _M_value;    
    };

    template <typename CharT, typename Traits>
    std::basic_ostream<CharT, Traits> &
    operator<<(std::basic_ostream<CharT, Traits> &out, const sep &s)
    {
        free(reinterpret_cast<void *>(out.iword(sep::index())));
        out.iword(sep::index()) = reinterpret_cast<long>(s._M_value ? strdup(s._M_value) : 0);
        return out;
    }    

    namespace tuplarr {

        // printon policy 
        //

        template <typename CharT, typename Traits, typename T, int N>
        struct printon
        {
            static void apply(std::basic_ostream<CharT,Traits> &out, const T &tupl)
            {
                out << std::get< std::tuple_size<T>::value - N>(tupl) << ' ';
                printon<CharT, Traits, T,N-1>::apply(out,tupl);
            }

        };
        template <typename CharT, typename Traits, typename T>
        struct printon<CharT, Traits, T,0>
        {
            static void apply(std::basic_ostream<CharT, Traits> &, const T &)
            {}
        };
    }

} // namespace streamer
} // namespace more


namespace std {

    ///////////////////////////////////////
    // operator<< for generic containers...
    //

    template <typename CharT, typename Traits, typename T>
    inline typename std::enable_if<more::traits::is_container<T>::value && 
    !is_same<typename std::string,T>::value, 
        std::basic_ostream<CharT,Traits>>::type &
    operator<<(std::basic_ostream<CharT,Traits> &out, const T &v)
    {
        std::copy(v.begin(), v.end(), 
                  std::ostream_iterator<typename T::value_type>(
                      out, reinterpret_cast<char *>(out.iword(more::streamer::sep::index()))));
        return out;
    };

    //////////////////////////
    // operator<< for pair...

    template <typename CharT, typename Traits, typename U, typename V>
    inline std::basic_ostream<CharT, Traits> &
    operator<< (std::basic_ostream<CharT, Traits> &out, const std::pair<U,V> &r)
    {
        return out << '<' << r.first << ':' << r.second << '>';
    }

    ///////////////////////////
    // operator<< for array...

    template <typename CharT, typename Traits, typename T, std::size_t N>
    std::basic_ostream<CharT,Traits> &
    operator<<(std::basic_ostream<CharT,Traits> &out, const std::array<T,N> &rhs)
    {
        out << "[ ";
        more::streamer::tuplarr::printon<CharT, Traits, std::array<T,N>, N>::apply(out,rhs);
        return out << "]";
    }

    ////////////////////////////////////////////////////////
    // operator<< for tuple: (enabled if T is a tuple<>)... 

    template <typename CharT, typename Traits, typename T>
    typename std::enable_if< more::traits::is_tuple<T>::value, std::basic_ostream<CharT,Traits> >::type &
    operator<<(std::basic_ostream<CharT,Traits> &out, const T &rhs)
    {
        out << "< ";
        more::streamer::tuplarr::printon<CharT, Traits, T, std::tuple_size<T>::value>::apply(out,rhs);
        return out << ">";
    }

} // namespace std

/////////////////////////////////////////////////////////////////////////////////
// simple c++0x Oracle
//

struct O
{
    template <typename T, typename CharT, typename Traits>
    static void print_compat(std::basic_ostream<CharT,Traits> &out,const T &elem)
    {
        static std::string last_token;
#ifdef _REENTRANT 
        static std::mutex _S_mutex;
        std::lock_guard<std::mutex> _L_(_S_mutex);
#endif
        std::ostringstream ss; ss << elem;
        const std::string &token = ss.str();
        if ( last_token != token )  // flush
        {
            out << token; last_token = std::move(token);
        }
        else {
            out << '.';
        }
    }

    static std::string
    cxa_demangle(const char *name)
    {
#ifdef _REENTRANT 
        static std::mutex _S_mutex;
        std::lock_guard<std::mutex> _L_(_S_mutex);
#endif
        int status;
        std::shared_ptr<char> ret(abi::__cxa_demangle(name,0,0, &status), ::free);
        if (status < 0) {
            return std::string("?");
        }
        return std::string(ret.get());
    }

    O()                         { print_compat(std::cout," O()"); } 
    O(const O &)                { print_compat(std::cout," O(const O&)"); } 
    O &operator=(const O &)     { print_compat(std::cout," op=(const O&)"); return *this; } 
    ~O()                        { print_compat(std::cout," ~O()"); } 
    O(O &&)                     { print_compat(std::cout," O(O&&)"); } 
    O &operator=(O &&)          { print_compat(std::cout," op=(O&&)"); return *this; } 
    
    template <typename T> O(T)  
    { std::ostringstream ss; ss << " O(" << cxa_demangle(typeid(T).name()) << ")";
        print_compat(std::cout,ss.str().c_str()); } 

    void swap(O &rhs)           { print_compat(std::cout," swap(O,O)"); }
    bool operator<(const O &rhs) const
    {
         print_compat(std::cout," O<O");
         return this < &rhs;
    }
};  

template <typename CharT, typename Traits>
typename std::basic_ostream<CharT, Traits> &
operator<<(std::basic_ostream<CharT,Traits> &out, const O & rhs)
{
    std::ostringstream ss; ss << " O[" << (void *)&rhs << "]";
    O::print_compat(out, ss.str().c_str());
    return out;
}
 
using namespace std;
using namespace std::placeholders;

#endif /* _SNIPPET_HPP_ */
